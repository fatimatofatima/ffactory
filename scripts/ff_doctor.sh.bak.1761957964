MEMORY_SCRIPT="/opt/ffactory/scripts/system_memory.sh"
MEMORY_SCRIPT="/opt/ffactory/scripts/system_memory.sh"
mem_hook(){ [[ -f \"$MEMORY_SCRIPT\" ]] && \"$MEMORY_SCRIPT\" service_restart \"$svc\" \"$port\"; }
. /opt/ffactory/scripts/ff_lib.sh
#!/usr/bin/env bash
set -Eeuo pipefail

# -------- Config --------
FF="/opt/ffactory"
STACK="$FF/stack"
LOGS="$FF/logs"
ENV_FILE="$STACK/.env"
COMPOSE="$STACK/docker-compose.complete.yml"
[ -f "$COMPOSE" ] || COMPOSE="$STACK/docker-compose.ultimate.yml"
LOG_FILE="$LOGS/doctor_$(date +%Y%m%d_%H%M%S).log"

# -------- Helpers --------
log(){ echo -e "[\e[32m$(date +%H:%M:%S)\e[0m] $*" | tee -a "$LOG_FILE"; }
warn(){ echo -e "[\e[33m!\e[0m] $*" | tee -a "$LOG_FILE"; }
err(){ echo -e "[\e[31mâœ˜\e[0m] $*" | tee -a "$LOG_FILE"; exit 1; }
need_root(){ [[ $EUID -eq 0 ]] || err "Ù„Ø§Ø²Ù… ØªØ´ØºÙ‘Ù„ ÙƒÙ€ root"; }
has(){ command -v "$1" >/dev/null 2>&1; }
envv(){ set -a; [ -f "$ENV_FILE" ] && . "$ENV_FILE"; set +a; }

send_tg(){
  envv
  local msg="$1"
  if [[ -n "${TELEGRAM_BOT_TOKEN:-}" && -n "${TELEGRAM_CHAT_ID:-}" ]]; then
    curl -fsS -X POST "https://api.telegram.org/bot${TELEGRAM_BOT_TOKEN}/sendMessage" \
      -H "Content-Type: application/json" \
      -d "$(jq -nc --arg chat_id "$TELEGRAM_CHAT_ID" --arg text "$msg" '{chat_id:$chat_id,text:$text,disable_web_page_preview:true}')" >/dev/null 2>&1 || true
  fi
}

fix_compose(){
  # Ù†Ø¸Ù‘Ù CRLF/Tab/BOM + Ø§Ù…Ø³Ø­ version:
  sed -i 's/\r$//' "$COMPOSE" || true
  sed -i 's/\t/  /g' "$COMPOSE" || true
  sed -i '1 s/^\xEF\xBB\xBF//' "$COMPOSE" || true
  sed -i '/^version:/d' "$COMPOSE" || true
  docker compose --env-file "$ENV_FILE" -f "$COMPOSE" config >/dev/null || err "Ù…Ù„Ù compose ÙÙŠÙ‡ Ø®Ø·Ø£."
}

ensure_pg_env(){
  envv
  local changed=0
  for k in PGUSER PGPASSWORD PGDB PGPORT; do
    if ! grep -q "^$k=" "$ENV_FILE"; then
      changed=1
      case "$k" in
        PGUSER)      echo "PGUSER=${PGUSER:-forensic}" >> "$ENV_FILE" ;;
        PGPASSWORD)  echo "PGPASSWORD=${PGPASSWORD:-Forensic123!}" >> "$ENV_FILE" ;;
        PGDB)        echo "PGDB=${PGDB:-ffactory}" >> "$ENV_FILE" ;;
        PGPORT)      echo "PGPORT=${PGPORT:-5433}" >> "$ENV_FILE" ;;
      esac
    fi
  done
  if ! grep -q "^DATABASE_URL=" "$ENV_FILE"; then
    echo "DATABASE_URL=postgresql://${PGUSER:-forensic}:${PGPASSWORD:-Forensic123!}@db:${PGPORT:-5433}/${PGDB:-ffactory}" >> "$ENV_FILE"
    changed=1
  fi
  [ $changed -eq 1 ] && chmod 600 "$ENV_FILE" && log "ØªÙ… ØªØ­Ø¯ÙŠØ« .env Ø¨Ù‚ÙŠÙ… PG*" || true
}

# Ø§ÙƒØªØ´Ù Ø¨ÙˆØ±Øª Ø§Ù„Ø®Ø¯Ù…Ø© (Ø¯Ø§Ø®Ù„ÙŠ) Ø£Ùˆ Ø§Ø±Ø¬Ø¹ 8080
svc_port(){
  local svc="$1" p=""
  case "$svc" in
    case-manager) p=8140 ;;
    evidence-tracker) p=8141 ;;
    report-generator) p=8142 ;;
    audit-logger) p=8143 ;;
    feedback-api) p=8070 ;;
    orchestrator) p=8060 ;;
    ingest-service) p=8001 ;;
    media-forensics-pro) p=8001 ;;
    api-gateway) p=8170 ;;
    data-export-service) p=8172 ;;
    zero-trust-enforcer) p=8106 ;;
    advanced-steganalysis) p=8114 ;;
    memory-forensics) p=8115 ;;
    temporal-forensics) p=8116 ;;
    predictive-analytics) p=8125 ;;
    behavioral-patterns) p=8126 ;;
    linguistic-analysis) p=8127 ;;
    deepfake-detector) p=8128 ;;
    mobile-forensics) p=8130 ;;
    iot-forensics) p=8131 ;;
    cloud-forensics) p=8132 ;;
    blockchain-analyzer) p=8133 ;;
    geospatial-tracker) p=8122 ;;
    network-mapper) p=8123 ;;
    integrity-monitor) p=8100 ;;
    anomaly-detector) p=8101 ;;
    deception-detector) p=8102 ;;
    social-analyzer) p=8103 ;;
    chain-of-custody-manager) p=8105 ;;
    ai-reporting) p=8081 ;;
    quantum-security) p=8082 ;;
    correlation-engine) p=8083 ;;
    asr-engine) p=8085 ;;
    social-intelligence) p=8086 ;;
    neural-core) p=8082 ;;
    *) p=8080 ;;
  esac
  echo "$p"
}

http_health(){
  local svc="$1"
  local port="$(svc_port "$svc")"
  docker compose --env-file "$ENV_FILE" -f "$COMPOSE" exec -T "$svc" sh -lc "apk add --no-cache curl >/dev/null 2>&1 || true; curl -fsS http://127.0.0.1:${port}/health" >/dev/null 2>&1
}

inspect_status(){
  local cname="$1"
  docker inspect -f '{{.State.Status}} {{if .State.Health}}{{.State.Health.Status}}{{end}}' "$cname" 2>/dev/null || echo "unknown"
}

repair_svc(){
  local svc="$1"
  log "Ù…Ø­Ø§ÙˆÙ„Ø© Ø¥ØµÙ„Ø§Ø­: $svc"
  docker compose --env-file "$ENV_FILE" -f "$COMPOSE" up -d --build "$svc" || true
  sleep 5
  if http_health "$svc"; then
    log "âœ… $svc ØªØ¹Ø§ÙÙ‰ Ø¨Ø¹Ø¯ build/restart"
  else
    warn "$svc Ù…Ø§Ø²Ø§Ù„ ØºÙŠØ± Ø³Ù„ÙŠÙ…. Ø¢Ø®Ø± 80 Ø³Ø·Ø± Ù…Ù† Ø§Ù„Ù„ÙˆØ¬:"
    docker logs --tail=80 "ffactory_${svc//-/_}" 2>/dev/null || docker compose -f "$COMPOSE" logs --tail=80 "$svc" || true
    send_tg "âš ï¸ FFactory Doctor: ÙØ´Ù„ ÙØ­Øµ $svc Ø¨Ø¹Ø¯ Ø§Ù„Ø¥ØµÙ„Ø§Ø­."
  fi
}

make_health_html(){
  envv
  local out="$LOGS/health_$(date +%Y%m%d_%H%M%S).html"
  local svcs=($(docker compose --env-file "$ENV_FILE" -f "$COMPOSE" ps --services 2>/dev/null || true))
  {
    echo '<!doctype html><meta charset="utf-8"><title>FFactory Health</title>'
    echo '<style>body{font-family:system-ui;margin:24px} .ok{color:#0a0} .bad{color:#c00} .warn{color:#b80} table{border-collapse:collapse} td,th{border:1px solid #ddd;padding:6px 10px}</style>'
    echo "<h1>FFactory Health - $(date)</h1><table><tr><th>Service</th><th>Status</th><th>HTTP /health</th></tr>"
    for s in "${svcs[@]}"; do
      st="$(inspect_status "ffactory_${s//-/_}")"
      if http_health "$s"; then h="OK"; cls="ok"; else h="FAIL"; cls="bad"; fi
      echo "<tr><td>$s</td><td>$st</td><td class=\"$cls\">$h</td></tr>"
    done
    echo "</table>"
  } > "$out"
  # Ø§Ù†Ø³Ø®Ù‡Ø§ Ù„Ù„ÙØ±ÙˆÙ†Øª Ù„Ùˆ Ù…ÙˆØ¬ÙˆØ¯
  docker cp "$out" ffactory_frontend_dashboard:/usr/share/nginx/html/health.html >/dev/null 2>&1 || true
  log "Health HTML: $out (ÙˆØ£ÙŠØ¶Ù‹Ø§ Ù†ÙØ³ÙØ®Øª Ø¥Ù„Ù‰ frontend-dashboard Ø¥Ù† Ø£Ù…ÙƒÙ†)"
}

main(){
  need_root
  has docker || err "Docker ØºÙŠØ± Ù…Ø«Ø¨Øª"
  has jq || { log "ØªØ«Ø¨ÙŠØª jq Ù…Ø¤Ù‚ØªÙ‹Ø§â€¦"; apt-get update -y && apt-get install -y jq >/dev/null; }
  fix_compose
  ensure_pg_env

  log "ÙØ­Øµ Ø§Ù„Ø¨Ù†ÙŠØ© Ø§Ù„ØªØ­ØªÙŠØ©â€¦"
  docker compose --env-file "$ENV_FILE" -f "$COMPOSE" up -d db redis neo4j minio ollama vault >/dev/null 2>&1 || true

  # Ø§Ù„Ø®Ø¯Ù…Ø§Øª Ø§Ù„Ù‡Ø¯Ù (Ù„Ùˆ ps empty Ù†Ø¬ÙŠØ¨ services Ù…Ù† compose)
  mapfile -t services < <(docker compose --env-file "$ENV_FILE" -f "$COMPOSE" ps --services 2>/dev/null || awk '/^[[:space:]]{2}[A-Za-z0-9_-]+:/{gsub(":","");print $1}' "$COMPOSE")
  [ "${#services[@]}" -eq 0 ] && err "Ù„Ù… Ø§Ø³ØªØ·Ø¹ Ù‚Ø±Ø§Ø¡Ø© Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø®Ø¯Ù…Ø§Øª."

  log "Ø¨Ø¯Ø¡ ÙØ­Øµ / Ø¥ØµÙ„Ø§Ø­ Ù„Ù„Ø®Ø¯Ù…Ø§Øªâ€¦"
  for s in "${services[@]}"; do
    if http_health "$s"; then
      log "ğŸŸ¢ $s ØµØ­ÙŠÙ‘"
    else
      warn "ğŸ”´ $s ØºÙŠØ± ØµØ­ÙŠÙ‘ â€” Ø³ÙŠØªÙ… Ø§Ù„Ø¥ØµÙ„Ø§Ø­"
      repair_svc "$s"
    fi
  done

  make_health_html
  log "ØªÙ…."
}

main "$@"
